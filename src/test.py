from problems import *


if __name__ == "__main__":
    mySolution = Solution()

    # gas = [1,2,3,3]
    # cost = [2,1,5,1]
    # result = mySolution.canCompleteCircuit(gas, cost)

    # ratings = [4,2,3,4,1]
    # result = mySolution.candy(ratings)

    # nums = [3, 1]
    # target = 3
    # result = mySolution.searchII(nums, target)

    # nums = [-1,0,1,2,-1,-4]
    # result = mySolution.threeSum(nums)
    # print result
    # result = mySolution.threeSum2(nums)

    # list1 = [5]
    # list2 = [6]

    # l1 = ListNode(-1)
    # h1 = l1
    # for i in list1:
    #     h1.next = ListNode(i)
    #     h1 = h1.next
    #
    # l2 = ListNode(-1)
    # h2 = l2
    # for i in list2:
    #     h2.next = ListNode(i)
    #     h2 = h2.next
    #
    # result = mySolution.addTwoNumbers(l1.next, l2.next)

    # list = [1,2,3]
    #
    # l1 = ListNode(-1)
    # h1 = l1
    # for i in list:
    #     h1.next = ListNode(i)
    #     h1 = h1.next
    #
    # result = mySolution.reverseBetween(l1.next, 1, 3)

    # list = [1,2,3]
    #
    # l1 = ListNode(-1)
    # h1 = l1
    # for i in list:
    #     node = ListNode(i)
    #     h1.next = node
    #     h1 = h1.next
    #
    # result = mySolution.reorderList(l1.next)

    # s = "baabbaaa"
    # result = mySolution.longestPalindrome(s)

    # s = "aab"
    # p = "c*a*b"
    # result = mySolution.isMatch_recurrsive(s, p)

    # s = "()" # 6
    # result = mySolution.longestValidParentheses1(s)

    # s = [2,4,5,3,1]
    # result = mySolution.largestRectangleArea(s)

    # tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
    # result = mySolution.evalRPN(tokens)

    # s = "DCXXI"
    # result = mySolution.romanToInt(s)

    # s = [2,1,5,7,3,9,6,8,4,8]
    # dummy = ListNode(0)
    # head = dummy
    # for i in s:
    #     head.next = ListNode(i)
    #     head = head.next
    # result = mySolution.sortList(dummy.next)

    # result = mySolution.minimumTotal([[2],[3,4],[6,5,7],[4,1,8,3]])

    # nums = [-2,1,-3,4,-1,2,1,-5,4]
    # result = mySolution.maxSubArray(nums)

    # s = "aab"
    # result = mySolution.minCut_DP(s)

    # matrix = [[0,0,0,0],[0,0,1,0],[0,1,1,0],[1,0,1,1]]
    # result = mySolution.maximalRectangle(matrix)


    # s = "abcde"; t = "ace"
    # result = mySolution.numDistinct(s,t)

    # result = mySolution.numScore(12)

    # word1 = "ace"
    # word2 = "abcde"
    # result = mySolution.minDistance(word1, word2)

    # s = "c"
    # p = "*?*"
    # result = mySolution.isMatch_dp(s, p)

    # result = mySolution.numSquares(13)

    # result = mySolution.minCut_ddpp("ab")

    # result = mySolution.maxProduct([-4,-3])

    # result = mySolution.lengthOfLIS([3,4,-1,5,8,2,3,12,7,9,10])

    # result = mySolution.maxProfit([1,2,3,0,2])

    # result = mySolution.partition_dp("aab")

    # result = mySolution.solveNQueens(8)

    # result = mySolution.restoreIpAddresses("001001")

    # result = mySolution.combinationSum2([10,1,2,7,6,1,5], 8)

    # result = mySolution.searchInsert([1,3,5,7], 4)

    # result = mySolution.spiralOrder([[1,11,21],[2,12,22],[3,13,23],[4,14,24],[5,15,25],[6,16,26],[7,17,27],[8,18,28],[9,19,29],[10,20,30]])

    # intervals = [Interval(1,4), Interval(2,5)]
    # result = mySolution.merge(intervals)

    # result = mySolution.canJump([2,0,1,0,1])

    # result = mySolution.longestConsecutive([100, 4, 200, 1, 3, 2])

    # result = mySolution.twoSum([2, 7, 11, 15], 9)

    # result = mySolution.threeSum([-1,0,1,2,-1,-4], 0)

    # result = mySolution.fourSum([1,0,-1,0,-2,2], 0)

    # result = mySolution.removeElement([-1,0,1,2,-1,-4], -1)

    # result = mySolution.nextPermutation([1,2,3,4,5])

    # result = mySolution.fourSum([1,0,-1,0,-2,2], 0)

    # result = mySolution.getPermutation2(6, 400)

    # matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12],[13,14,15,16]]
    # result = mySolution.rotateimage(matrix)

    # result = mySolution.grayCode(2)

    # result = mySolution.findLadders('a', 'c', ['a', 'b', 'c'])

    # result = mySolution.canJump([3,2,1,0,4])

    # s = [1,2,3,4,5]
    # dummy = ListNode(0)
    # head = dummy
    # for i in s:
    #     head.next = ListNode(i)
    #     head = head.next
    # result = mySolution.reverseBetween(dummy.next, 2, 4)

    # root = TreeNode(2)
    # root.left = TreeNode(3)
    # root.right = TreeNode(1)
    # result = mySolution.recoverTree(root)

    # root1 = TreeNode(0)
    # root2 = TreeNode(0)
    # result = mySolution.isSameTree(root1, root2)

    # result = mySolution.restoreIpAddresses('0000')

    # nums = [-2,1,-3,4,-1,2,1,-5,4]
    # nums = [-2,1]
    # result = mySolution.maxSubArray(nums)

    # result = mySolution.isScramble("great", "rgeat")

    # result = mySolution.numDecodings("101")

    # result = mySolution.wordBreak("abbcd", set(["a","b","bcd","cd"]))

    # result = mySolution.numSquares(6)
    # matrix = ["10100","10111","11111","10010"]
    # result = mySolution.maximalSquare(matrix)

    # nums = [2,5,6,3,7,4]
    # result = mySolution.lengthOfLIS_dp()
    # result = mySolution.robcircle(nums)

    # result = mySolution.coinChange([186,419,83,408], 6249)

    # result = mySolution.maxCoins([3,1,5,8])

    # result = mySolution.maxProfitDP([1,2,3,0,2])

    # result = mySolution.longestConsecutive_new([-3,2,8,5,1,7,-8,2,-8,-4,-1,6,-6,9,6,0,-7,4,5,-4,8,2,0,-2,-6,9,-4,-1])

    # result = mySolution.threeSumdfs([-1,0,1,2,-1,-4])

    # result = mySolution.singleNumber([2,2,3,2])

    # result = mySolution.insert([Interval(0, 4), Interval(7, 12)], Interval(0, 5))

    # s = [8,9,9]
    # dummy1 = ListNode(0)
    # head = dummy1
    # for i in s:
    #     head.next = ListNode(i)
    #     head = head.next
    #
    # s = [2]
    # dummy2 = ListNode(0)
    # head = dummy2
    # for i in s:
    #     head.next = ListNode(i)
    #     head = head.next
    #
    # result = mySolution.addTwoNumbers(dummy1.next, dummy2.next)

    # result = mySolution.restoreIpAddresses_new("0000")

    # board = ["53..7....","6..195...",".98....6.","8...6...3","4..8.3..1","7...2...6",".6....28.","...419..5","....8..79"]
    # result = mySolution.solveSudoku(board)

    # result = mySolution.buildTable('aabaa')

    # result = mySolution.partition('aab')

    # result = mySolution.lengthOfLIS([1,3,6,7,9,4,10,5,6])

    # result = mySolution.maxProfit([3,5,6,2,6,4,3])

    # result = mySolution.maxProfit4(3, [3,5,6,2,6,4,3])
    # result = mySolution.maxCoins([3,1,5,8])

    result = mySolution.isHappy(1111111)
    print result





